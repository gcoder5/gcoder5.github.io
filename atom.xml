<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GCoder-BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gcoder5.com/"/>
  <updated>2020-05-19T14:31:59.000Z</updated>
  <id>https://gcoder5.com/</id>
  
  <author>
    <name>GCoder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>那些让人爱恨交加的指令们</title>
    <link href="https://gcoder5.com/article/583cf726.html"/>
    <id>https://gcoder5.com/article/583cf726.html</id>
    <published>2020-05-19T12:08:32.000Z</published>
    <updated>2020-05-19T14:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚入码场的我们，不得不跟各种各样的工具，层出不穷的指令打交道。而最最可恨的是我们总是容易忘记指令，可能是用得少，可能是记性不好。所以GCoder这个健忘代表，决定用日志的形式，把我们会遇见的指令统统记下来，然后持续<font color="#dd000"><strong>更新维护</strong></font>起来！</p><a id="more"></a><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><blockquote><p>Git is a <a href="https://git-scm.com/about/free-and-open-source" target="_blank" rel="noopener">free and open source</a> distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p><p>Git是一个免费的开源分布式版本控制系统，旨在快速高效地管理从小型到大型项目的所有内容。</p></blockquote><p>相信大家对Git都有或多或少的了解，简单明了的说，它就是帮助我们管理项目的开发版本，让多人协作的开发更加的高效。以下GCoder用自己理解的Git工作流程共享大家，希望能给各位Git小白看客们能有一点启发～</p><p>希望通过简单的例子可以让大家看懂：</p><p>GCoder有一家AJ总店，有AJ1和AJ2两款鞋；有门店A和门店B两家分店</p><blockquote><p><font color="#dd000">GCoder有一个远程仓库（总店），有基础代码（AJ1和AJ2），有两个本地仓库（门店A和门店B）</font></p></blockquote><p>第一天，门店A和门店B，从总店进了AJ1和AJ2这两款鞋来卖</p><blockquote><p><font color="#dd000">本地仓库可以从远程仓库上拉取最新的代码</font></p></blockquote><p>第二天，总店进货了，有了AJ3的鞋款，两家分店知道了总店有了新鞋款，就赶紧来进货</p><blockquote><p><font color="#dd000">当远程仓库更新代码后，本地仓库可以实时拉取最新的代码</font></p></blockquote><p>第三天，门店A从境外进了AJ4的鞋款，并将货源供给了总店，门店B经由总店也开始销售AJ4</p><blockquote><p><font color="#dd000">本地仓库更新代码，可以提交到远程仓库进行管理，其他本地仓库可以拉取到最新的代码</font></p></blockquote><p>第四天，总店觉得AJ2销量不大，就把它下架了，并同时让分店也下架了这个鞋款</p><blockquote><p><font color="#dd000">远程仓库删减代码，本地仓库拉取后，也是会同步进行修改（实际跟第二天是一样的道理）</font></p></blockquote><p>第五天，门店B觉得AJ8利润大，就偷偷找了代理商C，不仅卖所有鞋款，还卖AJ8，而这件事总店不知道</p><blockquote><p><font color="#dd000">本地仓库新建了一个分支（代理商C），只要不提交到远程仓，那就是你本地仓自己的事儿～（远程仓肯定也能建分支）</font></p></blockquote><p>基本的流程就是这样，只要我们记得我们代表本地仓，可以跟远程仓进行同步，然后远程仓对所有本地仓的代码进行同步管理，就over了（附上一张粗略的流程图）～<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gey2snlkkjj31aw0j6n0v.jpg" alt="git_work"></p><p>如果你想了解更多，我也找了篇比较详细的文章推荐给大家<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">Git工作流程</a></p><h4 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.将远程仓的代码克隆到本地（Clone a repository into a new directory）</span></span><br><span class="line">git clone [git_remote_url] #默认所有分支都克隆</span><br><span class="line">git clone -b [branch_name] --single--branch [git_remote_url] #指定分支克隆</span><br><span class="line"><span class="meta">#</span><span class="bash">2.提交流程相关</span></span><br><span class="line">(1)workspace --&gt; index</span><br><span class="line">git add &lt;file1 .. file2&gt; #将指定文件存到本地仓库的暂存区（这时候这些文件已经受git管理）</span><br><span class="line">git add &lt;directory&gt; #将指定目录存到暂存区</span><br><span class="line">git add . #将当前目录所有变化的文件存到暂存区</span><br><span class="line">git add -u #只保存除新增外的文件到暂存区</span><br><span class="line">git add -f &lt;file1 .. file2&gt; #不管.gitignore是否保存该文件，强制存到暂存区</span><br><span class="line">(2)index --&gt;repository</span><br><span class="line">git commit -m "message" #将暂存区代码提交到本地仓库，-m是必需的，指定commit消息</span><br><span class="line">(3)repository --&gt;remote</span><br><span class="line">git push [remote_name] [remote_branch_name] #将本地仓库的代码推送到远程仓的指定分支</span><br><span class="line">git push [remote_name] --delete [remote_branch_name] #等同上一条指令，不存在分支则新建</span><br><span class="line">git push [remote_name] #推送到远程仓与本地仓库对应的这个分支上</span><br><span class="line">git push #只有一个远程仓库 也可以这样直接推送 与上一条指令一样</span><br><span class="line"><span class="meta">#</span><span class="bash">3.远程仓怎么看</span></span><br><span class="line">git remote -v #显示所有的远程仓(格式:[remote_name] [remote_url])</span><br><span class="line">git remote show [remote_name] #查看指定远程仓的具体信息</span><br><span class="line">git remote add [remote_name] [remote_url] #新增远程仓</span><br><span class="line"><span class="meta">#</span><span class="bash">4.分支</span></span><br><span class="line">git branch #查看本地所有分支(*代表当前在哪个分支上)</span><br><span class="line">git branch -a #查看本地和远程所有的分支</span><br><span class="line">git branch [branch_name] #新建本地分支</span><br><span class="line">git checkout [branch_name] #切换到指定分支</span><br><span class="line">git checkout -b [branch_name] #新建本地分支并切换</span><br><span class="line">git checkout -d [branch_name] #删除指定本地分支</span><br><span class="line">git checkout -D [branch_name] #强制删除指定本地分支</span><br><span class="line">git branch -m [new_branch_name] #给本地分支改名</span><br><span class="line">git branch -m [branch_name] [new_branch_name] #给指定分支改名</span><br><span class="line">git branch --merged #查看merge的情况</span><br><span class="line"><span class="meta">#</span><span class="bash">5.拉取</span></span><br><span class="line">git fetch #将远程仓的最新代码拉取到本地 但是合不合并到本地分支由你说了算，要的话就merge</span><br><span class="line">git pull #相当于git fetch +git merge 拉取最新代码并合并到对应分支(可能引发冲突)</span><br><span class="line"><span class="meta">#</span><span class="bash">6.提交记录</span></span><br><span class="line">git log #查看本地的所有提交历史</span><br><span class="line">git log --follow [file] #查看某个文件的改动历史</span><br><span class="line">git log [remote_name/remote_branch_name] #查看远程分支的变动情况</span><br><span class="line">git log --author=[author_name] #查看指定提交者的提交历史</span><br><span class="line">git log -i --grep="something in the commit-message" #模糊查看提交消息的历史</span><br><span class="line">git log --graph #提交历史图形化</span><br><span class="line">git log --decorate #显示commit里的分支</span><br><span class="line">git log --pretty=oneline #每个commit只显示一行</span><br><span class="line">git log --abbrev-commit #只显示commitId的前7位</span><br><span class="line">git log -[number] #指定查看几个commit</span><br><span class="line">git show [commitId] #查看指定commit的变化</span><br><span class="line"><span class="meta">#</span><span class="bash">7.初始化</span></span><br><span class="line">git init #将当前目录转换成git本地仓库 生成.git文件</span><br><span class="line"><span class="meta">#</span><span class="bash">8.暂存</span></span><br><span class="line">git stash #暂时保存没有提交的改动代码</span><br><span class="line">git stash list #查看所有的暂存工作</span><br><span class="line">git stash apply [stash_id] #恢复指定暂存工作(不会删除stash_id这个暂存工作)</span><br><span class="line">git stash pop #恢复最近的一次暂存工作 并删除</span><br><span class="line">git stash clear #删除所有暂存工作</span><br><span class="line">git stash drop #删除最近的一次暂存工作</span><br><span class="line"><span class="meta">#</span><span class="bash">9.撤销commit提交</span></span><br><span class="line">git revert [commitId]</span><br><span class="line"><span class="meta">#</span><span class="bash">10.回滚</span></span><br><span class="line">git reset HEAD~[number] #将当前分支回退指定个commit 并且会更改暂存区</span><br><span class="line">git reset --soft HEAD~[number] #不改变暂存区</span><br><span class="line">git reset --hard HEAD~[number] #强制回退 清空所有变动(慎用!)</span><br><span class="line">git reset [commitId] #指定回退到某个commit 改动文件还存在</span><br><span class="line">git reset #撤销上一次向暂存区提交的文件</span><br><span class="line"><span class="meta">#</span><span class="bash">11.可视化</span></span><br><span class="line">gitk --all #打开git内置的可视化界面</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚入码场的我们，不得不跟各种各样的工具，层出不穷的指令打交道。而最最可恨的是我们总是容易忘记指令，可能是用得少，可能是记性不好。所以GCoder这个健忘代表，决定用日志的形式，把我们会遇见的指令统统记下来，然后持续&lt;font color=&quot;#dd000&quot;&gt;&lt;strong&gt;更新维护&lt;/strong&gt;&lt;/font&gt;起来！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://gcoder5.com/categories/Java/"/>
    
    
      <category term="命令" scheme="https://gcoder5.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="git" scheme="https://gcoder5.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java不得不说的九种基本数据类型</title>
    <link href="https://gcoder5.com/article/10089.html"/>
    <id>https://gcoder5.com/article/10089.html</id>
    <published>2020-05-16T12:18:55.000Z</published>
    <updated>2020-05-19T12:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><ul><li><p><strong>Byte</strong>(字节)和<strong>bit</strong>(比特)的关系</p></li><li><p>电脑是以二进制储存以及发送接收数据的，bit作为信息技术的最基本储存单位，是二进制数中的一个数位，即0或者1</p></li><li><p>Byte是字节的英文单词，它可以简称为B</p></li></ul><p><strong>字节 Byte 和比特 bit 的换算关系是 <font color="#dd0000">1 Byte = 8 bit</font></strong> </p><p>既然说到了字节，那我们就不得不提一下<strong>字节和字符的区别</strong></p><table><thead><tr><th>-</th><th>定义</th></tr></thead><tbody><tr><td>字节（Byte）</td><td>字节是计算机存储容量的计量单位，表示数据量多少，1B=8bit</td></tr><tr><td>字符（Character）</td><td>计算机中使用的文字和符号（如’A’、’你’、’$’等）</td></tr></tbody></table><p>而值得我们注意的是一般情况下：</p><ul><li>一个英文字符就是一个字节，也就是1B<ul><li>一个中文字符就是两个字节，也就是2B</li></ul></li></ul></blockquote><p>作为一名Java程序员，首篇技术文我还是决定从基础的数据类型讲起，主要是考虑到我的博客是一个循序渐进的过程。希望把技术主干搭好，然后一步步的穿插其他的技术文，丰富起来，就好比git的master和其他的branch。废话不多说，以下进入正题</p><a id="more"></a><h3 id="整型-4"><a href="#整型-4" class="headerlink" title="整型(4)"></a>整型(4)</h3><p>整型指的是有范围限制的整数，Java的整型有四种。一般默认整型是int！</p><p>ps：有无符号的整型就是指的能不能存放负数</p><h4 id="1-byte"><a href="#1-byte" class="headerlink" title="1.byte"></a>1.byte</h4><ul><li><p>byte类型占<strong>8位</strong>，是<strong>有符号整型</strong>，范围长度是$-2^7$到$2^7-1$，即<strong>-128</strong>到<strong>127</strong></p></li><li><p>默认值是0</p></li><li><p>它对应的包装类是<strong>java.lang.Byte</strong>，内容分析与Integer类似，这里就不再赘述。<a href="####3.int"><font color="#dd000"><strong>参见int分析</strong></font></a></p></li></ul><h4 id="2-short"><a href="#2-short" class="headerlink" title="2.short"></a>2.short</h4><ul><li><p>short类型占<strong>16位</strong>，是<strong>有符号整型</strong>，范围长度是$-2^{15}$到$2^{15}-1$，即<strong>-32768</strong>到<strong>32767</strong></p></li><li><p>默认值是0</p></li><li><p>它对应的包装类是<strong>java.lang.Short</strong>，内容分析与Integer类似，这里就不再赘述。<font color="#dd000"><strong>参见int分析</strong></font></p></li></ul><h4 id="3-int"><a href="#3-int" class="headerlink" title="3.int"></a>3.int</h4><p>首先，我们从一道面试题来引入关于int的内容</p><blockquote><p>面试题:int与Integer的区别是什么？</p></blockquote><p>int类型占<strong>32位</strong>，是<strong>有符号整型</strong>，范围长度是$-2^{31}$到$2^{31}-1$，即<strong>-2,147,483,648</strong>到<strong>2,147,483,647</strong></p><table><thead><tr><th>int</th><th>Integer</th></tr></thead><tbody><tr><td>int是一种基本数据类型</td><td>Integer是int的包装类(也就提供了多种方法来处理int数据)</td></tr><tr><td>不需要实例化，直接拿来定义变量类型</td><td>需要实例化才能使用</td></tr><tr><td>默认值是0</td><td>默认值是null</td></tr><tr><td>直接储存数据值(堆栈)</td><td>对象的引用，new之后生成指针指向对象(具体实例保存在堆)</td></tr></tbody></table><p>在Integer源码中有这么一段描述</p><blockquote><p>The Integer class wraps a value of the primitive type int in an object. An object of type Integer contains a single field whose type is int</p><p>译文：Integer类将原始类型int的值包装在对象中。类型为Integer的对象包含一个类型为int的字段</p><p>In addition, this class provides several methods for converting an int to a String and a String to an int, as well as other constants and methods useful when dealing with an int.</p><p>译文：另外，此类提供了几种将int转换为String并将String转换为int的方法，以及其他在处理int时有用的常量和方法。</p></blockquote><p>具体的方法可以查看Integer的API文档<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html" target="_blank" rel="noopener">Integer jkd8 api</a>，常见的几种方法有如下：</p><p><strong>（1）来自父类的方法</strong></p><p><font color="#dd000">其他的基本数据类型包装类也是继承自Number,所有也有这些方法</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer 部分源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The value of the &#123;<span class="doctag">@code</span> Integer&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the value of this &#123;<span class="doctag">@code</span> Integer&#125; as a &#123;<span class="doctag">@code</span> byte&#125;</span></span><br><span class="line"><span class="comment">   * after a narrowing primitive conversion.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@jls</span> 5.1.3 Narrowing Primitive Conversions</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">byteValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">byte</span>)value;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the value of this &#123;<span class="doctag">@code</span> Integer&#125; as a &#123;<span class="doctag">@code</span> double&#125;</span></span><br><span class="line"><span class="comment">   * after a widening primitive conversion.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@jls</span> 5.1.2 Widening Primitive Conversions</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">double</span>)value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上将Integer转成byte，short，int，long，float，double六种方法是Integer重写了父类Number的方法，通过源码我们可以看到这些方法的本质是进行强制类型转换，返回指定类型，这里的话，需要注意两个问题：</p><ul><li><p>取值范围大的强转成取值范围小的</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子:Integer转byte（byte的取值范围是-128到127）</span></span><br><span class="line">Integer i = <span class="number">130</span>;</span><br><span class="line">System.out.println(<span class="string">"i.byteValue() = "</span> + i.byteValue());</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">i.byteValue() = -<span class="number">126</span></span><br></pre></td></tr></table></figure><p> 补充说明：</p><p> 之所以最终结果输出是-126，是因为Integer的i的值是130已经是超过了byte的最大值，分析结果我们可以这么看：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">首先，将130转成二进制数据：</span><br><span class="line">&gt;&gt; 10000010</span><br><span class="line">其次，因为int类型是占4个字节(32位)，所以内存的表现形式就是：</span><br><span class="line">&gt;&gt; 00000000 00000000 00000000 10000010</span><br><span class="line">然后，因为byte是占1个字节，所以截取8位，为：</span><br><span class="line">&gt;&gt; 10000010</span><br><span class="line">再者，通过最高符号位是1，我们可以判定这是个负数，因为计算机中所有的数据都是以补码的形式出现的，所以要计算它的补码：</span><br><span class="line">原码--&gt;反码：最高符号位不变，其他数值位1变0，0变1，即：</span><br><span class="line">原码：10000010</span><br><span class="line">反码：11111101</span><br><span class="line">反码--&gt;补码：反码加1就是补码，即</span><br><span class="line">反码：11111101</span><br><span class="line">补码：11111110</span><br><span class="line">所以最终转换结果就是：-(2^6+2^5+2^4+2^3+2^2+2^1)&#x3D;-(64+32+16+8+4+2)&#x3D;-126</span><br></pre></td></tr></table></figure></li><li><p>精度缺失</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子：Double转int</span></span><br><span class="line">Double d = <span class="number">19.83</span>d;</span><br><span class="line">System.out.println(<span class="string">"d.intValue() = "</span> + d.intValue());</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">d.intValue() = <span class="number">19</span></span><br></pre></td></tr></table></figure> <!--more--></li></ul><p><strong>（2）其他常见方法</strong></p><ul><li><p>一些简单的计算</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX_VALUE <span class="comment">//这是int取值范围的最大值，即2147483647</span></span><br><span class="line">Integer.sum(<span class="keyword">int</span> a,<span class="keyword">int</span> b);<span class="comment">//求和</span></span><br><span class="line">Integer.min(<span class="keyword">int</span> a,<span class="keyword">int</span> b);<span class="comment">//取二者的较小值</span></span><br><span class="line">Integer.max(<span class="keyword">int</span> a,<span class="keyword">int</span> b);<span class="comment">//取二者的较大值</span></span><br></pre></td></tr></table></figure></li><li><p>进制转换</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="keyword">int</span> i);<span class="comment">//转成二进制字符串</span></span><br><span class="line">Integer.toHexString(<span class="keyword">int</span> i);<span class="comment">//转成十六进制字符串</span></span><br><span class="line">Integer.toOctalString(<span class="keyword">int</span> i);<span class="comment">//转成八进制字符串</span></span><br></pre></td></tr></table></figure></li><li><p>类型转换</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(String s);<span class="comment">//将数值字符串转成int，如是不规范字符串会抛出NumberFormatException,raidx默认是10</span></span><br><span class="line">Integer.parseInt(String s,<span class="keyword">int</span> radix);<span class="comment">//可以指定转为几进制，MIN_RADIX默认是2,MAX_RADIX默认是36，例子（int i= Integer.parseInt("00000110",2);输出i=6）</span></span><br><span class="line">Integer.valueOf(String s);<span class="comment">//将字符串转成Integer，默认十进制</span></span><br><span class="line">Integer.valueOf(String s,<span class="keyword">int</span> radix);<span class="comment">//将字符串根据指定进制转成Integer</span></span><br><span class="line">Integer.valueOf(<span class="keyword">int</span> i);<span class="comment">//将int转成Integer</span></span><br></pre></td></tr></table></figure><p> <font color="#dd000" size ="4px">注意:</font><code>Integer.parseInt()和Integer.valueOf()的区别</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//valueOf()部分源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(parseInt(s, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们可以见到valueOf()方法的逻辑，就是通过调用parseInt()的返回值，作为参数再new一个Integer类型的实例返回，所以它们的区别是：</p><table><thead><tr><th>Integer.valueOf()</th><th>Integer.parseInt()</th></tr></thead><tbody><tr><td>返回类型是Integer，可以转成其他类型，如longValue()</td><td>返回类型是int</td></tr></tbody></table><p> 讲到这里，让我们回顾上段源码中的一个类<code>IntegerCache</code>，我在Integer中找到了这个静态内部类的一段描述</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment">     * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment">     * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment">     * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment">     * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment">     * sun.misc.VM class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//用我拙劣的英语给大家翻译下大致意思：</span></span><br><span class="line"><span class="comment">//1.JSL(Java编码规范)要求对数值从-128到127范围内的自动装箱的对象进行缓存</span></span><br><span class="line"><span class="comment">//2.当你第一次使用的时候这个缓存会初始化，这个缓存大小可以通过-XX:AutoBoxCacheMax=&lt;size&gt;来控制</span></span><br></pre></td></tr></table></figure><p> 下面，我再举个例子来说明上面这讲的是什么玩意儿～</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer n1 = <span class="number">123</span>;</span><br><span class="line">Integer n2 = <span class="number">123</span>;</span><br><span class="line">Integer n3 = <span class="number">128</span>;</span><br><span class="line">Integer n4 = <span class="number">128</span>;</span><br><span class="line">System.out.println(n1 == n2);</span><br><span class="line">System.out.println(n3 == n4);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="comment">//分析</span></span><br><span class="line"><span class="comment">/*因为n1和n2在缓存范围内，所有它们的值和地址都是指向同一个(缓存是在IntegerCache的数组中维护)，所以是true；但是因为n3和n4不在缓存返回内，所以会重新new一个Integer返回（具体可以看上面那个valueOf(int i)的源码），所以它们的引用地址并不同，返回false*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-long"><a href="#4-long" class="headerlink" title="4.long"></a>4.long</h4><ul><li><p>long类型占<strong>32位</strong>，是<strong>有符号整型</strong>，范围长度是$-2^{63}$到$2^{63}-1$，即<strong>-9,223,372,036,854,775,808</strong>到<strong>9,223,372,036,854,775,807</strong></p></li><li><p>默认值0L（避免小写字母l引发歧义，建议用大写字母）</p></li><li><p>它对应的包装类是<strong>java.lang.Long</strong>，内容分析与Integer类似，这里就不再赘述。<font color="#dd000"><strong>参见int分析</strong></font></p></li></ul><!--more--><h3 id="浮点型-2"><a href="#浮点型-2" class="headerlink" title="浮点型(2)"></a>浮点型(2)</h3><p>默认小数类型都是double！</p><h4 id="1-float"><a href="#1-float" class="headerlink" title="1.float"></a>1.float</h4><blockquote><p>单精度浮点数是用来表示带有小数部分的实数，一般用于科学计算。占用4个字节（32位）存储空间。单精度浮点数最多有7位十进制有效数字，超出部分自动四舍五入</p></blockquote><ul><li>float就是一个单精度的浮点数，32位</li><li>默认值是0.0f</li><li>float不能用来表示精确的值，如货币</li><li>它对应的包装类是<strong>java.lang.Float</strong></li></ul><p>从上面的第三点来看，既然float没办法表示精确的值，那Java又是通过什么类来表示精确的值呢？</p><p>答案：在这里我们就需要插入一段关于Java用来做高精度计算的两个类了，即<strong>java.math.BinInteger</strong>和<strong>java.math.BigDecimal</strong>，它们是提供了大数字（超过16位有效位）的操作类，也是Number的子类</p><p>其中 BigInteger 类是针对大整数的处理类,而 BigDecimal 类则是针对大小数的处理类</p><h4 id="2-double"><a href="#2-double" class="headerlink" title="2.double"></a>2.double</h4><blockquote><p>双精度浮点数(double)是计算机使用的一种数据类型，使用 64 位（8字节） 来存储一个浮点数。 它可以表示十进制的15或16位有效数字</p></blockquote><ul><li>double就是一个双精度的浮点数，64位</li><li>默认值是0.0d</li><li>double不能用来表示精确的值，如货币</li><li>它对应的包装类是<strong>java.lang.Double</strong></li></ul><h3 id="布尔型-1"><a href="#布尔型-1" class="headerlink" title="布尔型(1)"></a>布尔型(1)</h3><h4 id="1-boolean"><a href="#1-boolean" class="headerlink" title="1.boolean"></a>1.boolean</h4><p>下面是关于对boolean的官方文档描述</p><blockquote><p>boolean: The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its “size” isn’t something that’s precisely defined.</p><p>布尔类型：布尔数据类型只有两个可能的值：真和假。使用此数据类型为跟踪真/假条件的简单标记。这种数据类型就表示这一点信息，但是它的“大小”并不是精确定义的。</p></blockquote><ul><li><p>boolean是一个逻辑值，是所有关系运算符返回的类型</p></li><li><p>boolean只有true和false两种取值</p></li><li><p>它对应的包装类是<strong>java.lang.Boolean</strong></p></li></ul><h3 id="字符类型-1"><a href="#字符类型-1" class="headerlink" title="字符类型(1)"></a>字符类型(1)</h3><h4 id="1-char"><a href="#1-char" class="headerlink" title="1.char"></a>1.char</h4><ul><li><p>char类型是一个单一的16位Unicode 字符，可以储存任何字符</p></li><li><p>char类型赋值：char c = ‘a’;</p></li><li><p>char类型是可以在ASCII等字符编码表找到对应的数值，所以可以运算</p><ul><li><a href="http://ascii.911cha.com/" target="_blank" rel="noopener">ASCII字符编码表</a></li></ul></li><li><p>最小值是\u000，即0</p></li><li><p>最大值是\uffff，即65535</p></li><li><p>它对应的包装类是<strong>java.lang.Character</strong></p></li></ul><h3 id="void-1"><a href="#void-1" class="headerlink" title="void(1)"></a>void(1)</h3><h4 id="1-void"><a href="#1-void" class="headerlink" title="1.void"></a>1.void</h4><p>大家可能很疑惑，为什么会有这个第九个基本数据类型，一般不是都说只有八个基本数据类型吗。其实这个void被归为基本数据类型是有根据的，在thinking in java 这本书的<code>2.2.2 特例:基本类型</code>就把void归为基本数据类型了</p><ul><li>void是一个关键字，表示方法没有返回值</li><li>它对应的包装类是<strong>java.lang.Void</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Void完整源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Void</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Class&#125; object representing the pseudo-type corresponding to</span></span><br><span class="line"><span class="comment">     * the keyword &#123;<span class="doctag">@code</span> void&#125;.</span></span><br><span class="line"><span class="comment">     * 表示与关键字void对应的伪类型的Void对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass(<span class="string">"void"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The Void class cannot be instantiated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段源码很简略，我们就讲一讲这个Class的<code>getPrimitiveClass</code>，它是一个native方法，在<code>Class.c</code>中有个<code>Java_java_lang_Class_getPrimitiveClass</code>方法与之对应，所以JVM层面会通过<code>JVM_FindPrimitiveClass</code>函数根据”void”字符串获得jclass，最终到Java层则为<code>Class&lt;Void&gt;</code>（<font color="#dd000">其他的基本数据类型包装类中也能找到该方法</font>）</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>果然写文章是挺累人的！这篇文章的篇幅比较长，能看到这里的，不胜感激</p><p>其实九种基本数据类型对应的包装类都是大同小异，为了基本数据类型提供更多的方法接口来更好的处理数据</p><p>这篇文章就权当是Java系列文的抛砖引玉，争取慢慢的将文章写得更好</p><p>END</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Byte&lt;/strong&gt;(字节)和&lt;strong&gt;bit&lt;/strong&gt;(比特)的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;电脑是以二进制储存以及发送接收数据的，bit作为信息技术的最基本储存单位，是二进制数中的一个数位，即0或者1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Byte是字节的英文单词，它可以简称为B&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字节 Byte 和比特 bit 的换算关系是 &lt;font color=&quot;#dd0000&quot;&gt;1 Byte = 8 bit&lt;/font&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;既然说到了字节，那我们就不得不提一下&lt;strong&gt;字节和字符的区别&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;字节（Byte）&lt;/td&gt;
&lt;td&gt;字节是计算机存储容量的计量单位，表示数据量多少，1B=8bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符（Character）&lt;/td&gt;
&lt;td&gt;计算机中使用的文字和符号（如’A’、’你’、’$’等）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;而值得我们注意的是一般情况下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个英文字符就是一个字节，也就是1B&lt;ul&gt;
&lt;li&gt;一个中文字符就是两个字节，也就是2B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一名Java程序员，首篇技术文我还是决定从基础的数据类型讲起，主要是考虑到我的博客是一个循序渐进的过程。希望把技术主干搭好，然后一步步的穿插其他的技术文，丰富起来，就好比git的master和其他的branch。废话不多说，以下进入正题&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://gcoder5.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://gcoder5.com/tags/Java/"/>
    
      <category term="数据类型" scheme="https://gcoder5.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>蓄谋已久的自我介绍</title>
    <link href="https://gcoder5.com/article/8964.html"/>
    <id>https://gcoder5.com/article/8964.html</id>
    <published>2020-05-14T13:44:37.000Z</published>
    <updated>2020-05-18T13:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>hello，everyone!</p><p>我是GCoder（小声哔哔:听说博主都需要有个笔名），可以是G-Coder，也可以是GC-oder，这些都无伤大雅。我只是一个名不见经传的Java小码农，码龄估摸着得有两年了，初入博场，希望各位看官们多多关照。</p><h4 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h4><p>以大学毕业后半年为分水岭的话，前世我是一个正儿八经的机械工科生，上到机械设计，下到机械原理，我都是略有耳闻！毕业后，咱也是如同千万学子一般在诚惶诚恐和欣喜若狂之间的找到了自己的第一份工作（售前工程师），就这样干了半年，直到2017年的年前某一天，我突然细品了我的生活模式–枯燥，无味，过于安逸。我反复推敲，认真问了自己一个问题“这是我喜欢这份工作吗？”，毕竟工作是之后很长一段时间都跟自己的生活息息相关的，我真的愿意一直干这样的工作吗。我迟疑了，先后跟各位长辈们聊了自己的想法，在2017年春节后，我毅然决然的离职，选择了自己感兴趣的编程，毕竟兴趣是最好的老师啊，也是生活最佳的调味剂。而今生的故事是从半年的培训讲起，一路的磕磕碰碰，虽然无情，但也不觉得累，更多的是一种满足，那种发自内心的对感兴趣的东西，追求过程中的起起伏伏的一种刺激，一种勉励，一种全新的生活。</p><a id="more"></a><h4 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h4><p>作为一名程序员，我知道那种对技术渴求的感觉，也明白心态对生活的重要性。讲真的，我已经蓄谋已久想作为一名新时代的程序员来发发言，聊聊技术，吹吹水，跟大伙交流一下。所以，在我的博客里，我大致讲内容分成三块。</p><h5 id="技术文章（70-）"><a href="#技术文章（70-）" class="headerlink" title="技术文章（70%）"></a>技术文章（70%）</h5><p>技术文章是基础课程，发文有这么几个目的：</p><ul><li>记录学习的内容，做好笔记。因为我一直相信温故而知新，可以为师！</li><li>与看官们交流下技术，提升自己的认知。因为我知道三人行，必有我师！</li><li>从小白而来，为小白而去。我希望我的小白笔记可以帮助更多的IT萌新！</li></ul><h5 id="杂谈（20-）"><a href="#杂谈（20-）" class="headerlink" title="杂谈（20%）"></a>杂谈（20%）</h5><p>为什么要有杂谈，到底多杂，想怎么谈？生活有百态，每一态都有它独特的韵味，我们在追求技术的同时，不妨听听其他生活的声音，充实而又丰富的生活节奏，岂不快哉。</p><ul><li>杂谈范围极广，GCoder有什么心得啊，想法啊，都会写上来（其中不乏心灵鸡汤哈哈哈）</li><li>分享趣事，包括GCoder自己的一些兴趣啊（跑马，球类，极限运动，书籍等等）</li></ul><h5 id="水文（10-）"><a href="#水文（10-）" class="headerlink" title="水文（10%）"></a>水文（10%）</h5><p>人跟人之间最重要的理解，而理解的基础是沟通，水文之所以能水，就是因为能说！为什么能说，就是在自己没技术文，没杂谈的情况下，不知道发什么，却又非得想发，大抵就是这样的文章！毫无实质内容，但是却想说说话！哈哈哈</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>GCoder是一个G姓Coder的小星球。</p><p>GCoder又可以是GC和oder，垃圾回收订单。把我们的学习心得理解看成是一个个的“垃圾”，当每一个“垃圾”作为订单被各位看官们不断的消费的时候，“垃圾”会在交流中得到废品回收的效果，重新塑造一个全新的自己，这是初衷，也是博客存在的一点微薄作用。</p><p>我是GCoder，一名热爱技术的Java程序员，一名半吊子跑马选手，如果你爱技术，你爱生活，欢迎你们的关注，兴许我们是志同道合的“狐朋狗友”。岁月漫长，承蒙关照！</p><p><strong>In a lifetime ,happy to meet you.thanks.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello，everyone!&lt;/p&gt;
&lt;p&gt;我是GCoder（小声哔哔:听说博主都需要有个笔名），可以是G-Coder，也可以是GC-oder，这些都无伤大雅。我只是一个名不见经传的Java小码农，码龄估摸着得有两年了，初入博场，希望各位看官们多多关照。&lt;/p&gt;
&lt;h4 id=&quot;前世今生&quot;&gt;&lt;a href=&quot;#前世今生&quot; class=&quot;headerlink&quot; title=&quot;前世今生&quot;&gt;&lt;/a&gt;前世今生&lt;/h4&gt;&lt;p&gt;以大学毕业后半年为分水岭的话，前世我是一个正儿八经的机械工科生，上到机械设计，下到机械原理，我都是略有耳闻！毕业后，咱也是如同千万学子一般在诚惶诚恐和欣喜若狂之间的找到了自己的第一份工作（售前工程师），就这样干了半年，直到2017年的年前某一天，我突然细品了我的生活模式–枯燥，无味，过于安逸。我反复推敲，认真问了自己一个问题“这是我喜欢这份工作吗？”，毕竟工作是之后很长一段时间都跟自己的生活息息相关的，我真的愿意一直干这样的工作吗。我迟疑了，先后跟各位长辈们聊了自己的想法，在2017年春节后，我毅然决然的离职，选择了自己感兴趣的编程，毕竟兴趣是最好的老师啊，也是生活最佳的调味剂。而今生的故事是从半年的培训讲起，一路的磕磕碰碰，虽然无情，但也不觉得累，更多的是一种满足，那种发自内心的对感兴趣的东西，追求过程中的起起伏伏的一种刺激，一种勉励，一种全新的生活。&lt;/p&gt;
    
    </summary>
    
    
      <category term="首文" scheme="https://gcoder5.com/categories/%E9%A6%96%E6%96%87/"/>
    
    
      <category term="GCoder" scheme="https://gcoder5.com/tags/GCoder/"/>
    
  </entry>
  
</feed>
