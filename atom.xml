<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GCoder-BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gcoder5.com/"/>
  <updated>2020-07-05T02:05:50.000Z</updated>
  <id>https://gcoder5.com/</id>
  
  <author>
    <name>GCoder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机与网络--总结(一)</title>
    <link href="https://gcoder5.com/article/95c553fc.html"/>
    <id>https://gcoder5.com/article/95c553fc.html</id>
    <published>2020-07-04T01:09:35.000Z</published>
    <updated>2020-07-05T02:05:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="停更的自我狡辩"><a href="#停更的自我狡辩" class="headerlink" title="停更的自我狡辩"></a>停更的自我狡辩</h3><p>说正文前，先来对停更做出一些狡辩。偷懒和贪婪真的是人类的两大原罪，虽说停更的这个月确实生活跌宕起伏，就像林宥嘉的歌一样，真的是一夜之间变成了大人。害，但是生活还是要继续的。在组长的训导之下幡然醒悟，还是要继续努力记录技术，学习技术啊，不然怎么做喜欢的事情呢～</p><p>所以，我Gcoder又回来了，先总结一篇最近看的书，叫做《图解TCP/IP》，借由这本书和自己总结的一些东西记录成这篇文章，也希望让看官们有点收获。</p><a id="more"></a><h3 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h3><h4 id="计算机与网络发展的七个阶段"><a href="#计算机与网络发展的七个阶段" class="headerlink" title="计算机与网络发展的七个阶段"></a>计算机与网络发展的七个阶段</h4><ul><li><p><strong>第一阶段 &gt;&gt;&gt; 批处理（Batch Processing）</strong></p><blockquote><p>时间：20世纪50年代</p><p>需求背景：用于大规模计算或者处理</p><p>解释：所谓批处理，是指事先将用户程序和数据装入卡带或磁带，让计算机按照一定顺序读取，使得用户要执行的程序和数据一并批量得到处理</p></blockquote></li><li><p><strong>第二阶段 &gt;&gt;&gt; 分时系统（Time Sharing System）</strong></p><blockquote><p>时间：20世纪60年代</p><p>需求背景：计算机造价昂贵，分时系统实现了“一人一机”的需求，这里也提出了一个重要特性–独占性</p><p>解释：所谓分时系统，是指多个终端跟同一个计算机连接，允许多个用户同时使用一个计算机的系统</p></blockquote></li><li><p><strong>第三阶段 &gt;&gt;&gt; 计算机之间的通信</strong></p><blockquote><p>时间：20世纪70年代</p><p>需求背景：计算机体型变小，价格降低，为了满足引入企业处理日常事务，提供计算机之间的交互</p><p>解释：计算机之间的通信改善了最早通过物理方式传递不同计算机数据的问题，大大提升了不同计算机传送数据的效率</p></blockquote></li><li><p><strong>第四阶段 &gt;&gt;&gt; 计算机网络的产生</strong></p><blockquote><p>时间：20世纪80年代</p><p>需求背景：从70年代初，实验基于分组交换技术的计算机网络，得到了完善的研究</p><p>解释：80年代一种能够互连多种计算机的网络随之诞生，它能够让各式各样的计算机互相连接，从大型的超级计算机或主机到小型的个人电脑（窗口系统的发明也是在这个时候从出现的，窗口系统即是在计算机中可以打开多个图形窗口进行处理的系统）</p></blockquote></li><li><p><strong>第五阶段 &gt;&gt;&gt; 互联网的普及</strong></p><blockquote><p>时间：20世纪90年代</p><p>需求背景：想要形成“一人一机”的环境（包括网络环境）的成本不菲，并且会遇到很多新问题，所以提出了“瘦身”和“多供应商”连接这两个口号</p><p>解释：为了在连接不同厂商的计算机建立一个成本更低的网络技术，各个厂商不仅保证自家产品的互联性，还着力于自己的网络技术不断与互联网技术兼容</p></blockquote></li><li><p><strong>第六阶段 &gt;&gt;&gt; 以互联网技术为中心的时代</strong></p><blockquote><p>时间：2000年</p><p>需求背景：互联网的普及和发展对通信领域产生巨大影响</p><p>解释：各种发展道路各不相同的网络技术向互联网靠拢，IP（Internet Protocol）网应运而生，通过IP网，人们可以实现电话通信，电视播放，还能实现计算机之间的通信，建立互联网</p></blockquote></li><li><p><strong>第七阶段 &gt;&gt;&gt; 从“单纯建立连接”到“安全建立连接”</strong></p><blockquote><p>时间：2010年</p><p>需求背景：信息网络环境的便捷也带来了计算机病毒的侵害，信息泄漏，网络欺诈的一些犯罪行为</p><p>解释：公司和社会团体在建立互联网连接前，应理解通信网络的机制、充分考虑联网后的日常运维流程以及基本的“自我防卫”手段</p></blockquote></li></ul><!--more--><h4 id="关于协议"><a href="#关于协议" class="headerlink" title="关于协议"></a>关于协议</h4><blockquote><p>在计算机网络和信息通信领域中，我们所耳熟能详的协议，比如IP、TCP、HTTP等</p><p>而TCP/IP就是IP、TCP、HTTP等协议的集合</p><ul><li><p><strong>协议的定义</strong></p><p>协议就是计算机和计算机之间通过网络实现通信时事先达成的一种“约定”。只有遵循相同的协议就能够实现通信</p></li><li><p><strong>分组交换协议</strong></p><p>分组交换就是把大数据分割为一个个叫做包（package）的较小单位进行传输的方法。我们将</p><p>发送端地址和接收端地址以及分组序号写入的部分称为“报文首部”</p></li><li><p><strong>协议是谁规定的</strong></p><p>ISO（International Organization for Standards）国际标准化组织</p><p>国际标准OSI（Open Systems Interconection）开放式通信系统互联参考模型</p></li></ul></blockquote><h4 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h4><table><thead><tr><th>层级</th><th>名字</th><th>作用</th></tr></thead><tbody><tr><td>第一层</td><td>物理层</td><td>解决两台物理机之间的通讯需求，机器A往机器B发送bit流，<br />机器B能够接收到这些bit流；<br />物理层定义了物理设备的标准：网线的类型、光纤的接口类型、<br />各种传输介质的传播速率；<br />网卡就是工作在这一层的；</td></tr><tr><td>第二层</td><td>数据链路层</td><td>传输bit流的时候，会发生漏传，误传的情况，而数据链路层<br />就是定义了如何格式化数据来进行传输；<br />这一层通常还做错误检查和纠正，以确保数据传输的准确性；<br />交换机就是工作在这一层；</td></tr><tr><td>第三层</td><td>网络层</td><td>将网络地址翻译成对应的物理地址，并决定如何将数据从<br />发送方路由到接收方<br />网络层通过综合考虑发送优先权、网络拥塞程度、服务质量<br />以及可选择路由的花费，来决定从一个网络中节点A到节点B的最佳路径<br />路由器属于网络层；</td></tr><tr><td>第四层</td><td>传输层</td><td>传输层是OSI模型最重要的一层；<br />解决了主机间的数据传输，数据间的传输可以是可以是不同<br />网络的，并且传输层解决了传输质量的问题；<br />传输协议可以进行流量控制，根据接收数据快慢程度，规定<br />适当的发送速率；<br />传输层按照网络能够处理的最大尺寸，将较长的数据包，进行强制分割；</td></tr><tr><td>第五层</td><td>会话层</td><td>建立和管理应用程序之间的通信；<br />保证应用程序会自动收发发包和寻址；</td></tr><tr><td>第六层</td><td>表示层</td><td>解决不同系统之间的通信语法的问题，在表示层，数据将按照<br />网络能够理解的方案进行格式化，这种格式化也因所使用的网络类型不同而不同；</td></tr><tr><td>第七层</td><td>应用层</td><td>规定发送方和接收方必须使用一个固定长度的消息头，消息头<br />必须使用某种固定的组成，而且消息头中必须记录消息体的长度等一系列信息；<br />应用层旨在让你更方便的应用从网络中接受到的数据；<br />该层需要我们重点关注的与之相对应的tcp/ip协议中的http协议</td></tr></tbody></table><!--more--><h4 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h4><p>以下，我们通过一个HTTP请求的过程来了解关于HTTP请求和TCP请求的内容。</p><blockquote><p>一般而言，当我们发起某个域名的资源请求（例如：<a href="http://www.baidui.com）,浏览器会首先在本地DNS服务器查找IP地址，如果存在则直接返回IP信息，不存在就会访问其他的DNS服务器查找我们请求的IP地址。当我们找到了IP地址后，我们才可以建立连接，建立什么连接呢？首先，我们要记住一点，HTTP协议是基于TCP协议的，所以建立连接的第一步肯定是建立TCP连接（三次握手）。一旦TCP连接建立起来，HTTP请求就可以组织数据发送报文了。（HTTP协议的版本大部分是1.1，在这个版本中有一个属性Keep-Alive，这个属性表示要保持此HTTP连接建立的TCP连接，默认是开启的）">www.baidui.com）,浏览器会首先在本地DNS服务器查找IP地址，如果存在则直接返回IP信息，不存在就会访问其他的DNS服务器查找我们请求的IP地址。当我们找到了IP地址后，我们才可以建立连接，建立什么连接呢？首先，我们要记住一点，HTTP协议是基于TCP协议的，所以建立连接的第一步肯定是建立TCP连接（三次握手）。一旦TCP连接建立起来，HTTP请求就可以组织数据发送报文了。（HTTP协议的版本大部分是1.1，在这个版本中有一个属性Keep-Alive，这个属性表示要保持此HTTP连接建立的TCP连接，默认是开启的）</a></p><p>网络上有文章大篇幅描述http的长连接信息，其实是错误的说法，<strong>长连接是针对tcp连接</strong>，http连接打开<strong>keepalive</strong>选项只不过<strong>保持了tcp连接不断开</strong>而已。</p><p>HTTP报文结构和内容</p><table><thead><tr><th>请求报文</th><th>响应报文</th></tr></thead><tbody><tr><td>请求行（请求方法／HTTP协议版本）</td><td>状态行（状态码）</td></tr><tr><td>请求头部（Content-Type）</td><td>响应头部</td></tr><tr><td>空行</td><td>空行</td></tr><tr><td>请求体</td><td>响应体</td></tr></tbody></table><p>回顾我们刚刚说到的http协议位于应用层，所以要发送的报文首先会把http协议相关的内容包含在包中，然后传给传输层，而这一层主要的两个协议就是TCP和UDP，HTTP协议选择的是TCP协议，TCP会有两个端口信息，一个是源端口和一个是目标端口（HTTP请求一般目标端口是80），传输层把端口信息封装完毕，接着把请求包传给网络层。</p><p>网络层的协议是IP协议，在这一层会把源Ip地址和目标IP地址封装进去（目标IP就是请求的网站ip，查询dns获得）</p><p>操作系统知道了要发往的IP地址，会判断该IP地址是不是在本地局域网内（通过子网掩码来判断），如果不在就需要网关把这个请求发送出去（网关的IP一般是DHCP协议配置的），如果相同就会回复，经过这个过程，系统找到了网关，获取到了网关的MAC地址，并把网关的MAc地址和本机的MAc地址封装进请求包，发给下一层MAC层,最后网卡把消息发往网关</p><p>（MAC地址主要用在同一个局域网内定位某个计算机，是在局域网内才有效的地址）</p><p>请求包到达网关,网关会根据消息的MAC地址来判断是否和自己的mac相同，如果相同则把消息接收下来。接着会判断消息中目标IP，如果目标IP未在自己的局域网中，则需要根据自己的路由规则把消息发送给下一个相连的网关。</p><p>目标服务器收到消息会解析请求的消息，在对比完mac和IP信息之后，会得到端口的信息，目标服务器则在本机寻找监听这个端口的程序，http服务器很有可能是nginx或者其他web服务器。</p><p>请求通过端口传送给具体的处理的程序，程序会解析http请求的内容，根据内容作出相应的回复。</p><p>请求按照以上所有步骤把响应返回给请求方（网关路由器会记住来源路径），至此一个http请求结束。</p><p><a href="https://www.sohu.com/a/330099168_669829" target="_blank" rel="noopener">参考文档</a>：该文档描述详尽，本文引用其部分内容。</p></blockquote><p>本来，在本文是要展开说下一些协议的，比如UDP和TCP还有我们常用到的HTTP协议，但是我发现这一块的内容想要摸透还是需要单独拎出来讲的，那就留给下一篇，我们直奔主题的展开来一起学习下关于这些协议的一些东西，而本文就当是抛砖引玉了，因为讲到协议的时候我们还是会关联到本文的一些基本内容～</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;停更的自我狡辩&quot;&gt;&lt;a href=&quot;#停更的自我狡辩&quot; class=&quot;headerlink&quot; title=&quot;停更的自我狡辩&quot;&gt;&lt;/a&gt;停更的自我狡辩&lt;/h3&gt;&lt;p&gt;说正文前，先来对停更做出一些狡辩。偷懒和贪婪真的是人类的两大原罪，虽说停更的这个月确实生活跌宕起伏，就像林宥嘉的歌一样，真的是一夜之间变成了大人。害，但是生活还是要继续的。在组长的训导之下幡然醒悟，还是要继续努力记录技术，学习技术啊，不然怎么做喜欢的事情呢～&lt;/p&gt;
&lt;p&gt;所以，我Gcoder又回来了，先总结一篇最近看的书，叫做《图解TCP/IP》，借由这本书和自己总结的一些东西记录成这篇文章，也希望让看官们有点收获。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://gcoder5.com/categories/Java/"/>
    
    
      <category term="网络" scheme="https://gcoder5.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP请求过程" scheme="https://gcoder5.com/tags/HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于排序算法的那些事儿</title>
    <link href="https://gcoder5.com/article/503970b4.html"/>
    <id>https://gcoder5.com/article/503970b4.html</id>
    <published>2020-05-24T21:37:07.000Z</published>
    <updated>2020-05-24T23:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Gcoder常常为自己的算法基础薄弱而感到蕉绿。那能怎么办呢？只能够一步步的来把一些基础的算法记录下来，时常温习，让自己能够更深刻的认识它们，如果看官们你也跟我一样蕉绿，那就让我们一起来学习吧～下面我们一起学习下常见的那些个排序算法。</p><h3 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h3><p>选择排序是一种简单又直观的排序算法，无论是放什么数据都是O(n²)的时间复杂度。所以用它的时候，数据的规模越小越好。</p><p>算法思想：维护一个有序的部分，将无序部分最大的元素和最后一个元素相交换，交换后无序部分的最后一个元素也将有序。</p><p>排序原理：扫描整个序列，然后找出最小的一个元素，跟第一个元素交换，然后从剩下的元素中继续选择这种选择和交换的方式，最终形成一个有序的序列。</p><blockquote><p>以[38,65,98,75,12,25,50]为例：</p><p>第一趟排序:12, [38,65,98,75,25,50]</p><p>第二趟排序:12,25, [38,65,98,75,50]</p><p>第三趟排序:12,25, 38,[65,98,75,50]</p><p>第四趟排序:12,25, 38,50,[65,98,75]</p><p>第五趟排序:12,25, 38,50,65,[98,75]</p><p>第六趟排序:12,25, 38,50,65,75,[98]</p><p>第七趟排序:12,25, 38,50,65,75,98</p></blockquote><a id="more"></a><p>程序代码（Java）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.定义原始序列</span></span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">38</span>, <span class="number">65</span>, <span class="number">98</span>, <span class="number">75</span>, <span class="number">12</span>, <span class="number">25</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"原始序列 = "</span> + Arrays.toString(numbers));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.要经过i-1轮对比</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;<span class="comment">//定义最小值的下标</span></span><br><span class="line">            <span class="comment">//3.每一轮需要比较j次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[min] &gt; numbers[j]) &#123;</span><br><span class="line">                    min = j;<span class="comment">//更新记录最小值的下标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4.将找到的最小值跟i的值交换</span></span><br><span class="line">            <span class="keyword">if</span> (i != min) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = numbers[i];</span><br><span class="line">                numbers[i] = numbers[min];</span><br><span class="line">                numbers[min] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出每一轮变换后的序列</span></span><br><span class="line">            System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"次排序 = "</span> + Arrays.toString(numbers));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>程序代码（kotlin）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">selectSort1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//1.定义原始序列</span></span><br><span class="line">    <span class="keyword">val</span> numbers = intArrayOf(<span class="number">38</span>, <span class="number">65</span>, <span class="number">98</span>, <span class="number">75</span>, <span class="number">12</span>, <span class="number">25</span>, <span class="number">50</span>)</span><br><span class="line">    println(<span class="string">"原始序列 = "</span> + numbers.contentToString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.要经过i-1轮对比</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until numbers.size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> min = i <span class="comment">//定义最小值的下标</span></span><br><span class="line">        <span class="comment">//3.每一轮需要比较j次</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until numbers.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[min] &gt; numbers[j]) &#123;</span><br><span class="line">                min = j <span class="comment">//更新记录最小值的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将找到的最小值跟i的值交换</span></span><br><span class="line">        <span class="keyword">if</span> (i != min) &#123;</span><br><span class="line">            <span class="keyword">val</span> tmp = numbers[i]</span><br><span class="line">            numbers[i] = numbers[min]</span><br><span class="line">            numbers[min] = tmp</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出每一轮变换后的序列</span></span><br><span class="line">        println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"次排序 = "</span> + numbers.contentToString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gcoder常常为自己的算法基础薄弱而感到蕉绿。那能怎么办呢？只能够一步步的来把一些基础的算法记录下来，时常温习，让自己能够更深刻的认识它们，如果看官们你也跟我一样蕉绿，那就让我们一起来学习吧～下面我们一起学习下常见的那些个排序算法。&lt;/p&gt;
&lt;h3 id=&quot;1-选择排序&quot;&gt;&lt;a href=&quot;#1-选择排序&quot; class=&quot;headerlink&quot; title=&quot;1.选择排序&quot;&gt;&lt;/a&gt;1.选择排序&lt;/h3&gt;&lt;p&gt;选择排序是一种简单又直观的排序算法，无论是放什么数据都是O(n²)的时间复杂度。所以用它的时候，数据的规模越小越好。&lt;/p&gt;
&lt;p&gt;算法思想：维护一个有序的部分，将无序部分最大的元素和最后一个元素相交换，交换后无序部分的最后一个元素也将有序。&lt;/p&gt;
&lt;p&gt;排序原理：扫描整个序列，然后找出最小的一个元素，跟第一个元素交换，然后从剩下的元素中继续选择这种选择和交换的方式，最终形成一个有序的序列。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以[38,65,98,75,12,25,50]为例：&lt;/p&gt;
&lt;p&gt;第一趟排序:12, [38,65,98,75,25,50]&lt;/p&gt;
&lt;p&gt;第二趟排序:12,25, [38,65,98,75,50]&lt;/p&gt;
&lt;p&gt;第三趟排序:12,25, 38,[65,98,75,50]&lt;/p&gt;
&lt;p&gt;第四趟排序:12,25, 38,50,[65,98,75]&lt;/p&gt;
&lt;p&gt;第五趟排序:12,25, 38,50,65,[98,75]&lt;/p&gt;
&lt;p&gt;第六趟排序:12,25, 38,50,65,75,[98]&lt;/p&gt;
&lt;p&gt;第七趟排序:12,25, 38,50,65,75,98&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://gcoder5.com/categories/Java/"/>
    
    
      <category term="kotlin" scheme="https://gcoder5.com/tags/kotlin/"/>
    
      <category term="排序算法" scheme="https://gcoder5.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>那些让人爱恨交加的指令们</title>
    <link href="https://gcoder5.com/article/583cf726.html"/>
    <id>https://gcoder5.com/article/583cf726.html</id>
    <published>2020-05-19T12:08:32.000Z</published>
    <updated>2020-05-22T23:43:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚入码场的我们，不得不跟各种各样的工具，层出不穷的指令打交道。而最最可恨的是我们总是容易忘记指令，可能是用得少，可能是记性不好。所以GCoder这个健忘代表，决定用日志的形式，把我们会遇见的指令统统记下来，然后持续<font color="#dd000"><strong>更新维护</strong></font>起来！</p><a id="more"></a><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><blockquote><p>Git is a <a href="https://git-scm.com/about/free-and-open-source" target="_blank" rel="noopener">free and open source</a> distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p><p>Git是一个免费的开源分布式版本控制系统，旨在快速高效地管理从小型到大型项目的所有内容。</p></blockquote><p>相信大家对Git都有或多或少的了解，简单明了的说，它就是帮助我们管理项目的开发版本，让多人协作的开发更加的高效。以下GCoder用自己理解的Git工作流程共享大家，希望能给各位Git小白看客们能有一点启发～</p><p>希望通过简单的例子可以让大家看懂：</p><p>GCoder有一家AJ总店，有AJ1和AJ2两款鞋；有门店A和门店B两家分店</p><blockquote><p><font color="#dd000">GCoder有一个远程仓库（总店），有基础代码（AJ1和AJ2），有两个本地仓库（门店A和门店B）</font></p></blockquote><p>第一天，门店A和门店B，从总店进了AJ1和AJ2这两款鞋来卖</p><blockquote><p><font color="#dd000">本地仓库可以从远程仓库上克隆最新的代码</font></p></blockquote><p>第二天，总店进货了，有了AJ3的鞋款，两家分店知道了总店有了新鞋款，就赶紧来进货</p><blockquote><p><font color="#dd000">当远程仓库更新代码后，本地仓库可以实时拉取最新的代码</font></p></blockquote><p>第三天，门店A从境外进了AJ4的鞋款，并将货源供给了总店，门店B经由总店也开始销售AJ4</p><blockquote><p><font color="#dd000">本地仓库更新代码，可以提交到远程仓库进行管理，其他本地仓库可以拉取到最新的代码</font></p></blockquote><p>第四天，总店觉得AJ2销量不大，就把它下架了，并同时让分店也下架了这个鞋款</p><blockquote><p><font color="#dd000">远程仓库删减代码，本地仓库拉取后，也是会同步进行修改（实际跟第二天是一样的道理）</font></p></blockquote><p>第五天，门店B觉得AJ8利润大，就偷偷找了代理商C，不仅卖所有鞋款，还卖AJ8，而这件事总店不知道</p><blockquote><p><font color="#dd000">本地仓库新建了一个分支（代理商C），只要不提交到远程仓，那就是你本地仓自己的事儿～（远程仓肯定也能建分支）</font></p></blockquote><p>基本的流程就是这样，只要我们记得我们代表本地仓，可以跟远程仓进行同步，然后远程仓对所有本地仓的代码进行同步管理，就over了（附上一张粗略的流程图）～<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gey2snlkkjj31aw0j6n0v.jpg" alt="git_work"></p><p>如果你想了解更多，我也找了篇比较详细的文章推荐给大家<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">Git工作流程</a></p><h4 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.将远程仓的代码克隆到本地（Clone a repository into a new directory）</span></span><br><span class="line">git clone [git_remote_url] #默认所有分支都克隆</span><br><span class="line">git clone -b [branch_name] --single--branch [git_remote_url] #指定分支克隆</span><br><span class="line"><span class="meta">#</span><span class="bash">2.提交流程相关</span></span><br><span class="line">(1)workspace --&gt; index</span><br><span class="line">git add &lt;file1 .. file2&gt; #将指定文件存到本地仓库的暂存区（这时候这些文件已经受git管理）</span><br><span class="line">git add &lt;directory&gt; #将指定目录存到暂存区</span><br><span class="line">git add . #将当前目录所有变化的文件存到暂存区</span><br><span class="line">git add -u #只保存除新增外的文件到暂存区</span><br><span class="line">git add -f &lt;file1 .. file2&gt; #不管.gitignore是否保存该文件，强制存到暂存区</span><br><span class="line">(2)index --&gt;repository</span><br><span class="line">git commit -m "message" #将暂存区代码提交到本地仓库，-m是必需的，指定commit消息</span><br><span class="line">(3)repository --&gt;remote</span><br><span class="line">git push [remote_name] [remote_branch_name] #将本地仓库的代码推送到远程仓的指定分支</span><br><span class="line">git push [remote_name] --delete [remote_branch_name] #等同上一条指令，不存在分支则新建</span><br><span class="line">git push [remote_name] #推送到远程仓与本地仓库对应的这个分支上</span><br><span class="line">git push #只有一个远程仓库 也可以这样直接推送 与上一条指令一样</span><br><span class="line"><span class="meta">#</span><span class="bash">3.远程仓怎么看</span></span><br><span class="line">git remote -v #显示所有的远程仓(格式:[remote_name] [remote_url])</span><br><span class="line">git remote show [remote_name] #查看指定远程仓的具体信息</span><br><span class="line">git remote add [remote_name] [remote_url] #新增远程仓</span><br><span class="line"><span class="meta">#</span><span class="bash">4.分支</span></span><br><span class="line">git branch #查看本地所有分支(*代表当前在哪个分支上)</span><br><span class="line">git branch -a #查看本地和远程所有的分支</span><br><span class="line">git branch [branch_name] #新建本地分支</span><br><span class="line">git checkout [branch_name] #切换到指定分支</span><br><span class="line">git checkout -b [branch_name] #新建本地分支并切换</span><br><span class="line">git checkout -d [branch_name] #删除指定本地分支</span><br><span class="line">git checkout -D [branch_name] #强制删除指定本地分支</span><br><span class="line">git branch -m [new_branch_name] #给本地分支改名</span><br><span class="line">git branch -m [branch_name] [new_branch_name] #给指定分支改名</span><br><span class="line">git branch --merged #查看merge的情况</span><br><span class="line"><span class="meta">#</span><span class="bash">5.拉取</span></span><br><span class="line">git fetch #将远程仓的最新代码拉取到本地 但是合不合并到本地分支由你说了算，要的话就merge</span><br><span class="line">git pull #相当于git fetch +git merge 拉取最新代码并合并到对应分支(可能引发冲突)</span><br><span class="line"><span class="meta">#</span><span class="bash">6.提交记录</span></span><br><span class="line">git log #查看本地的所有提交历史</span><br><span class="line">git log --follow [file] #查看某个文件的改动历史</span><br><span class="line">git log [remote_name/remote_branch_name] #查看远程分支的变动情况</span><br><span class="line">git log --author=[author_name] #查看指定提交者的提交历史</span><br><span class="line">git log -i --grep="something in the commit-message" #模糊查看提交消息的历史</span><br><span class="line">git log --graph #提交历史图形化</span><br><span class="line">git log --decorate #显示commit里的分支</span><br><span class="line">git log --pretty=oneline #每个commit只显示一行</span><br><span class="line">git log --abbrev-commit #只显示commitId的前7位</span><br><span class="line">git log -[number] #指定查看几个commit</span><br><span class="line">git show [commitId] #查看指定commit的变化</span><br><span class="line"><span class="meta">#</span><span class="bash">7.初始化</span></span><br><span class="line">git init #将当前目录转换成git本地仓库 生成.git文件</span><br><span class="line"><span class="meta">#</span><span class="bash">8.暂存</span></span><br><span class="line">git stash #暂时保存没有提交的改动代码</span><br><span class="line">git stash list #查看所有的暂存工作</span><br><span class="line">git stash apply [stash_id] #恢复指定暂存工作(不会删除stash_id这个暂存工作)</span><br><span class="line">git stash pop #恢复最近的一次暂存工作 并删除</span><br><span class="line">git stash clear #删除所有暂存工作</span><br><span class="line">git stash drop #删除最近的一次暂存工作</span><br><span class="line"><span class="meta">#</span><span class="bash">9.撤销commit提交</span></span><br><span class="line">git revert [commitId]</span><br><span class="line"><span class="meta">#</span><span class="bash">10.回滚</span></span><br><span class="line">git reset HEAD~[number] #将当前分支回退指定个commit 并且会更改暂存区</span><br><span class="line">git reset --soft HEAD~[number] #不改变暂存区</span><br><span class="line">git reset --hard HEAD~[number] #强制回退 清空所有变动(慎用!)</span><br><span class="line">git reset [commitId] #指定回退到某个commit 改动文件还存在</span><br><span class="line">git reset #撤销上一次向暂存区提交的文件</span><br><span class="line"><span class="meta">#</span><span class="bash">11.可视化</span></span><br><span class="line">gitk --all #打开git内置的可视化界面</span><br></pre></td></tr></table></figure><hr><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><h5 id="（1）诞生"><a href="#（1）诞生" class="headerlink" title="（1）诞生"></a>（1）诞生</h5><p>​        每个东西的诞生，都是因为有需求。在Maven诞生之前，程序员通常使用Ant来进行Java的构建，但是因为Ant仅仅是一个构建工具，它没有对项目本身进行管理，并且不能为软件消除软件构建的重复性，每个项目都要编写对应的Ant任务，因此，Maven应运而生。</p><h5 id="（2）作用"><a href="#（2）作用" class="headerlink" title="（2）作用"></a>（2）作用</h5><p>​        学习每一个东西，GCoder都建议从官网入手（别怕我们看不懂，毕竟有翻译嘛），从Maven的<a href="https://maven.apache.org/what-is-maven.html" target="_blank" rel="noopener">what is maven</a>节选了这么一段描述：</p><blockquote><p>Maven’s primary goal is to allow a developer to comprehend the complete state of a development effort in the shortest period of time. In order to attain this goal, Maven deals with several areas of concern:</p><ul><li>Making the build process easy</li><li>Providing a uniform build system</li><li>Providing quality project information</li><li>Encouraging better development practices</li></ul></blockquote><p>大致上就是说的Maven的几个优点，而每一点在上述官网有进行阐述，有兴趣的看客们可以移步官网，本文以指令记录为主，就不展开啦。</p><p>只要大家知道Maven通过<strong>坐标定位帮我们管理项目中的第三方库</strong>，我们可以从种类繁多的<a href="https://repo1.maven.org/maven2/" target="_blank" rel="noopener">中央仓库</a>中<strong>获取不同版本的第三方库</strong>，Maven还帮我们<strong>构建项目</strong>，<strong>处理第三方库的依赖关系</strong>就阔以了～</p><h4 id="2-指令-1"><a href="#2-指令-1" class="headerlink" title="2.指令"></a>2.指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">清除target目录</span></span><br><span class="line">mvn clean</span><br><span class="line"><span class="meta">#</span><span class="bash">编译项目主代码</span></span><br><span class="line">mvn compile</span><br><span class="line"><span class="meta">#</span><span class="bash">打包项目</span></span><br><span class="line">mvn package</span><br><span class="line"><span class="meta">#</span><span class="bash">编译并测试</span></span><br><span class="line">mvn test</span><br><span class="line"><span class="meta">#</span><span class="bash">将项目输出的jar安装到Maven本地仓库中</span></span><br><span class="line">mvn install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 以下常见参数 &lt;&lt;&lt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看maven版本</span></span><br><span class="line">mvn -v / mvn -version</span><br><span class="line"><span class="meta">#</span><span class="bash">显示详细错误信息（搭配上面构建指令） mvn clean -e </span></span><br><span class="line">mvn -e</span><br><span class="line"><span class="meta">#</span><span class="bash">跳过测试 不执行测试用例，也不编译测试用例类（搭配上面构建指令）</span></span><br><span class="line">mvn -Dmaven.test.skip=true</span><br><span class="line"><span class="meta">#</span><span class="bash">跳过测试 不执行测试用例，但会编译测试用例类（搭配上面构建指令）</span></span><br><span class="line">mvn -DskipTests</span><br><span class="line"><span class="meta">#</span><span class="bash">Debug模式，输出详细日志信息（搭配上面构建指令）</span></span><br><span class="line">mvn -X ／ mvn --debug</span><br><span class="line"><span class="meta">#</span><span class="bash">指定用户级别的settings配置文件</span></span><br><span class="line">mvn -s [filePath] /mvn --settings [filePath]</span><br><span class="line"><span class="meta">#</span><span class="bash">安静模式,只输出ERROR</span></span><br><span class="line">mvn -q / mvn --quiet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt;&gt;&gt; 常见指令搭配 (写几个供大家参考)&lt;&lt;&lt;</span></span><br><span class="line">mvn clean install -e -Dmaven.test.skip=true</span><br><span class="line">mvn compile -X</span><br><span class="line">mvn compild -s &lt;filePath&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚入码场的我们，不得不跟各种各样的工具，层出不穷的指令打交道。而最最可恨的是我们总是容易忘记指令，可能是用得少，可能是记性不好。所以GCoder这个健忘代表，决定用日志的形式，把我们会遇见的指令统统记下来，然后持续&lt;font color=&quot;#dd000&quot;&gt;&lt;strong&gt;更新维护&lt;/strong&gt;&lt;/font&gt;起来！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://gcoder5.com/categories/Java/"/>
    
    
      <category term="命令" scheme="https://gcoder5.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="git" scheme="https://gcoder5.com/tags/git/"/>
    
      <category term="maven" scheme="https://gcoder5.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Java不得不说的九种基本数据类型</title>
    <link href="https://gcoder5.com/article/10089.html"/>
    <id>https://gcoder5.com/article/10089.html</id>
    <published>2020-05-16T12:18:55.000Z</published>
    <updated>2020-05-19T12:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><ul><li><p><strong>Byte</strong>(字节)和<strong>bit</strong>(比特)的关系</p></li><li><p>电脑是以二进制储存以及发送接收数据的，bit作为信息技术的最基本储存单位，是二进制数中的一个数位，即0或者1</p></li><li><p>Byte是字节的英文单词，它可以简称为B</p></li></ul><p><strong>字节 Byte 和比特 bit 的换算关系是 <font color="#dd0000">1 Byte = 8 bit</font></strong> </p><p>既然说到了字节，那我们就不得不提一下<strong>字节和字符的区别</strong></p><table><thead><tr><th>-</th><th>定义</th></tr></thead><tbody><tr><td>字节（Byte）</td><td>字节是计算机存储容量的计量单位，表示数据量多少，1B=8bit</td></tr><tr><td>字符（Character）</td><td>计算机中使用的文字和符号（如’A’、’你’、’$’等）</td></tr></tbody></table><p>而值得我们注意的是一般情况下：</p><ul><li>一个英文字符就是一个字节，也就是1B<ul><li>一个中文字符就是两个字节，也就是2B</li></ul></li></ul></blockquote><p>作为一名Java程序员，首篇技术文我还是决定从基础的数据类型讲起，主要是考虑到我的博客是一个循序渐进的过程。希望把技术主干搭好，然后一步步的穿插其他的技术文，丰富起来，就好比git的master和其他的branch。废话不多说，以下进入正题</p><a id="more"></a><h3 id="整型-4"><a href="#整型-4" class="headerlink" title="整型(4)"></a>整型(4)</h3><p>整型指的是有范围限制的整数，Java的整型有四种。一般默认整型是int！</p><p>ps：有无符号的整型就是指的能不能存放负数</p><h4 id="1-byte"><a href="#1-byte" class="headerlink" title="1.byte"></a>1.byte</h4><ul><li><p>byte类型占<strong>8位</strong>，是<strong>有符号整型</strong>，范围长度是$-2^7$到$2^7-1$，即<strong>-128</strong>到<strong>127</strong></p></li><li><p>默认值是0</p></li><li><p>它对应的包装类是<strong>java.lang.Byte</strong>，内容分析与Integer类似，这里就不再赘述。<a href="####3.int"><font color="#dd000"><strong>参见int分析</strong></font></a></p></li></ul><h4 id="2-short"><a href="#2-short" class="headerlink" title="2.short"></a>2.short</h4><ul><li><p>short类型占<strong>16位</strong>，是<strong>有符号整型</strong>，范围长度是$-2^{15}$到$2^{15}-1$，即<strong>-32768</strong>到<strong>32767</strong></p></li><li><p>默认值是0</p></li><li><p>它对应的包装类是<strong>java.lang.Short</strong>，内容分析与Integer类似，这里就不再赘述。<font color="#dd000"><strong>参见int分析</strong></font></p></li></ul><h4 id="3-int"><a href="#3-int" class="headerlink" title="3.int"></a>3.int</h4><p>首先，我们从一道面试题来引入关于int的内容</p><blockquote><p>面试题:int与Integer的区别是什么？</p></blockquote><p>int类型占<strong>32位</strong>，是<strong>有符号整型</strong>，范围长度是$-2^{31}$到$2^{31}-1$，即<strong>-2,147,483,648</strong>到<strong>2,147,483,647</strong></p><table><thead><tr><th>int</th><th>Integer</th></tr></thead><tbody><tr><td>int是一种基本数据类型</td><td>Integer是int的包装类(也就提供了多种方法来处理int数据)</td></tr><tr><td>不需要实例化，直接拿来定义变量类型</td><td>需要实例化才能使用</td></tr><tr><td>默认值是0</td><td>默认值是null</td></tr><tr><td>直接储存数据值(堆栈)</td><td>对象的引用，new之后生成指针指向对象(具体实例保存在堆)</td></tr></tbody></table><p>在Integer源码中有这么一段描述</p><blockquote><p>The Integer class wraps a value of the primitive type int in an object. An object of type Integer contains a single field whose type is int</p><p>译文：Integer类将原始类型int的值包装在对象中。类型为Integer的对象包含一个类型为int的字段</p><p>In addition, this class provides several methods for converting an int to a String and a String to an int, as well as other constants and methods useful when dealing with an int.</p><p>译文：另外，此类提供了几种将int转换为String并将String转换为int的方法，以及其他在处理int时有用的常量和方法。</p></blockquote><p>具体的方法可以查看Integer的API文档<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html" target="_blank" rel="noopener">Integer jkd8 api</a>，常见的几种方法有如下：</p><p><strong>（1）来自父类的方法</strong></p><p><font color="#dd000">其他的基本数据类型包装类也是继承自Number,所有也有这些方法</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer 部分源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The value of the &#123;<span class="doctag">@code</span> Integer&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the value of this &#123;<span class="doctag">@code</span> Integer&#125; as a &#123;<span class="doctag">@code</span> byte&#125;</span></span><br><span class="line"><span class="comment">   * after a narrowing primitive conversion.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@jls</span> 5.1.3 Narrowing Primitive Conversions</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">byteValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">byte</span>)value;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the value of this &#123;<span class="doctag">@code</span> Integer&#125; as a &#123;<span class="doctag">@code</span> double&#125;</span></span><br><span class="line"><span class="comment">   * after a widening primitive conversion.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@jls</span> 5.1.2 Widening Primitive Conversions</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">double</span>)value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上将Integer转成byte，short，int，long，float，double六种方法是Integer重写了父类Number的方法，通过源码我们可以看到这些方法的本质是进行强制类型转换，返回指定类型，这里的话，需要注意两个问题：</p><ul><li><p>取值范围大的强转成取值范围小的</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子:Integer转byte（byte的取值范围是-128到127）</span></span><br><span class="line">Integer i = <span class="number">130</span>;</span><br><span class="line">System.out.println(<span class="string">"i.byteValue() = "</span> + i.byteValue());</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">i.byteValue() = -<span class="number">126</span></span><br></pre></td></tr></table></figure><p> 补充说明：</p><p> 之所以最终结果输出是-126，是因为Integer的i的值是130已经是超过了byte的最大值，分析结果我们可以这么看：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">首先，将130转成二进制数据：</span><br><span class="line">&gt;&gt; 10000010</span><br><span class="line">其次，因为int类型是占4个字节(32位)，所以内存的表现形式就是：</span><br><span class="line">&gt;&gt; 00000000 00000000 00000000 10000010</span><br><span class="line">然后，因为byte是占1个字节，所以截取8位，为：</span><br><span class="line">&gt;&gt; 10000010</span><br><span class="line">再者，通过最高符号位是1，我们可以判定这是个负数，因为计算机中所有的数据都是以补码的形式出现的，所以要计算它的补码：</span><br><span class="line">原码--&gt;反码：最高符号位不变，其他数值位1变0，0变1，即：</span><br><span class="line">原码：10000010</span><br><span class="line">反码：11111101</span><br><span class="line">反码--&gt;补码：反码加1就是补码，即</span><br><span class="line">反码：11111101</span><br><span class="line">补码：11111110</span><br><span class="line">所以最终转换结果就是：-(2^6+2^5+2^4+2^3+2^2+2^1)&#x3D;-(64+32+16+8+4+2)&#x3D;-126</span><br></pre></td></tr></table></figure></li><li><p>精度缺失</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子：Double转int</span></span><br><span class="line">Double d = <span class="number">19.83</span>d;</span><br><span class="line">System.out.println(<span class="string">"d.intValue() = "</span> + d.intValue());</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">d.intValue() = <span class="number">19</span></span><br></pre></td></tr></table></figure> <!--more--></li></ul><p><strong>（2）其他常见方法</strong></p><ul><li><p>一些简单的计算</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX_VALUE <span class="comment">//这是int取值范围的最大值，即2147483647</span></span><br><span class="line">Integer.sum(<span class="keyword">int</span> a,<span class="keyword">int</span> b);<span class="comment">//求和</span></span><br><span class="line">Integer.min(<span class="keyword">int</span> a,<span class="keyword">int</span> b);<span class="comment">//取二者的较小值</span></span><br><span class="line">Integer.max(<span class="keyword">int</span> a,<span class="keyword">int</span> b);<span class="comment">//取二者的较大值</span></span><br></pre></td></tr></table></figure></li><li><p>进制转换</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="keyword">int</span> i);<span class="comment">//转成二进制字符串</span></span><br><span class="line">Integer.toHexString(<span class="keyword">int</span> i);<span class="comment">//转成十六进制字符串</span></span><br><span class="line">Integer.toOctalString(<span class="keyword">int</span> i);<span class="comment">//转成八进制字符串</span></span><br></pre></td></tr></table></figure></li><li><p>类型转换</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(String s);<span class="comment">//将数值字符串转成int，如是不规范字符串会抛出NumberFormatException,raidx默认是10</span></span><br><span class="line">Integer.parseInt(String s,<span class="keyword">int</span> radix);<span class="comment">//可以指定转为几进制，MIN_RADIX默认是2,MAX_RADIX默认是36，例子（int i= Integer.parseInt("00000110",2);输出i=6）</span></span><br><span class="line">Integer.valueOf(String s);<span class="comment">//将字符串转成Integer，默认十进制</span></span><br><span class="line">Integer.valueOf(String s,<span class="keyword">int</span> radix);<span class="comment">//将字符串根据指定进制转成Integer</span></span><br><span class="line">Integer.valueOf(<span class="keyword">int</span> i);<span class="comment">//将int转成Integer</span></span><br></pre></td></tr></table></figure><p> <font color="#dd000" size ="4px">注意:</font><code>Integer.parseInt()和Integer.valueOf()的区别</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//valueOf()部分源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(parseInt(s, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们可以见到valueOf()方法的逻辑，就是通过调用parseInt()的返回值，作为参数再new一个Integer类型的实例返回，所以它们的区别是：</p><table><thead><tr><th>Integer.valueOf()</th><th>Integer.parseInt()</th></tr></thead><tbody><tr><td>返回类型是Integer，可以转成其他类型，如longValue()</td><td>返回类型是int</td></tr></tbody></table><p> 讲到这里，让我们回顾上段源码中的一个类<code>IntegerCache</code>，我在Integer中找到了这个静态内部类的一段描述</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment">     * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment">     * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment">     * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment">     * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment">     * sun.misc.VM class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//用我拙劣的英语给大家翻译下大致意思：</span></span><br><span class="line"><span class="comment">//1.JSL(Java编码规范)要求对数值从-128到127范围内的自动装箱的对象进行缓存</span></span><br><span class="line"><span class="comment">//2.当你第一次使用的时候这个缓存会初始化，这个缓存大小可以通过-XX:AutoBoxCacheMax=&lt;size&gt;来控制</span></span><br></pre></td></tr></table></figure><p> 下面，我再举个例子来说明上面这讲的是什么玩意儿～</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer n1 = <span class="number">123</span>;</span><br><span class="line">Integer n2 = <span class="number">123</span>;</span><br><span class="line">Integer n3 = <span class="number">128</span>;</span><br><span class="line">Integer n4 = <span class="number">128</span>;</span><br><span class="line">System.out.println(n1 == n2);</span><br><span class="line">System.out.println(n3 == n4);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="comment">//分析</span></span><br><span class="line"><span class="comment">/*因为n1和n2在缓存范围内，所有它们的值和地址都是指向同一个(缓存是在IntegerCache的数组中维护)，所以是true；但是因为n3和n4不在缓存返回内，所以会重新new一个Integer返回（具体可以看上面那个valueOf(int i)的源码），所以它们的引用地址并不同，返回false*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-long"><a href="#4-long" class="headerlink" title="4.long"></a>4.long</h4><ul><li><p>long类型占<strong>32位</strong>，是<strong>有符号整型</strong>，范围长度是$-2^{63}$到$2^{63}-1$，即<strong>-9,223,372,036,854,775,808</strong>到<strong>9,223,372,036,854,775,807</strong></p></li><li><p>默认值0L（避免小写字母l引发歧义，建议用大写字母）</p></li><li><p>它对应的包装类是<strong>java.lang.Long</strong>，内容分析与Integer类似，这里就不再赘述。<font color="#dd000"><strong>参见int分析</strong></font></p></li></ul><!--more--><h3 id="浮点型-2"><a href="#浮点型-2" class="headerlink" title="浮点型(2)"></a>浮点型(2)</h3><p>默认小数类型都是double！</p><h4 id="1-float"><a href="#1-float" class="headerlink" title="1.float"></a>1.float</h4><blockquote><p>单精度浮点数是用来表示带有小数部分的实数，一般用于科学计算。占用4个字节（32位）存储空间。单精度浮点数最多有7位十进制有效数字，超出部分自动四舍五入</p></blockquote><ul><li>float就是一个单精度的浮点数，32位</li><li>默认值是0.0f</li><li>float不能用来表示精确的值，如货币</li><li>它对应的包装类是<strong>java.lang.Float</strong></li></ul><p>从上面的第三点来看，既然float没办法表示精确的值，那Java又是通过什么类来表示精确的值呢？</p><p>答案：在这里我们就需要插入一段关于Java用来做高精度计算的两个类了，即<strong>java.math.BinInteger</strong>和<strong>java.math.BigDecimal</strong>，它们是提供了大数字（超过16位有效位）的操作类，也是Number的子类</p><p>其中 BigInteger 类是针对大整数的处理类,而 BigDecimal 类则是针对大小数的处理类</p><h4 id="2-double"><a href="#2-double" class="headerlink" title="2.double"></a>2.double</h4><blockquote><p>双精度浮点数(double)是计算机使用的一种数据类型，使用 64 位（8字节） 来存储一个浮点数。 它可以表示十进制的15或16位有效数字</p></blockquote><ul><li>double就是一个双精度的浮点数，64位</li><li>默认值是0.0d</li><li>double不能用来表示精确的值，如货币</li><li>它对应的包装类是<strong>java.lang.Double</strong></li></ul><h3 id="布尔型-1"><a href="#布尔型-1" class="headerlink" title="布尔型(1)"></a>布尔型(1)</h3><h4 id="1-boolean"><a href="#1-boolean" class="headerlink" title="1.boolean"></a>1.boolean</h4><p>下面是关于对boolean的官方文档描述</p><blockquote><p>boolean: The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its “size” isn’t something that’s precisely defined.</p><p>布尔类型：布尔数据类型只有两个可能的值：真和假。使用此数据类型为跟踪真/假条件的简单标记。这种数据类型就表示这一点信息，但是它的“大小”并不是精确定义的。</p></blockquote><ul><li><p>boolean是一个逻辑值，是所有关系运算符返回的类型</p></li><li><p>boolean只有true和false两种取值</p></li><li><p>它对应的包装类是<strong>java.lang.Boolean</strong></p></li></ul><h3 id="字符类型-1"><a href="#字符类型-1" class="headerlink" title="字符类型(1)"></a>字符类型(1)</h3><h4 id="1-char"><a href="#1-char" class="headerlink" title="1.char"></a>1.char</h4><ul><li><p>char类型是一个单一的16位Unicode 字符，可以储存任何字符</p></li><li><p>char类型赋值：char c = ‘a’;</p></li><li><p>char类型是可以在ASCII等字符编码表找到对应的数值，所以可以运算</p><ul><li><a href="http://ascii.911cha.com/" target="_blank" rel="noopener">ASCII字符编码表</a></li></ul></li><li><p>最小值是\u000，即0</p></li><li><p>最大值是\uffff，即65535</p></li><li><p>它对应的包装类是<strong>java.lang.Character</strong></p></li></ul><h3 id="void-1"><a href="#void-1" class="headerlink" title="void(1)"></a>void(1)</h3><h4 id="1-void"><a href="#1-void" class="headerlink" title="1.void"></a>1.void</h4><p>大家可能很疑惑，为什么会有这个第九个基本数据类型，一般不是都说只有八个基本数据类型吗。其实这个void被归为基本数据类型是有根据的，在thinking in java 这本书的<code>2.2.2 特例:基本类型</code>就把void归为基本数据类型了</p><ul><li>void是一个关键字，表示方法没有返回值</li><li>它对应的包装类是<strong>java.lang.Void</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Void完整源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Void</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Class&#125; object representing the pseudo-type corresponding to</span></span><br><span class="line"><span class="comment">     * the keyword &#123;<span class="doctag">@code</span> void&#125;.</span></span><br><span class="line"><span class="comment">     * 表示与关键字void对应的伪类型的Void对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass(<span class="string">"void"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The Void class cannot be instantiated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段源码很简略，我们就讲一讲这个Class的<code>getPrimitiveClass</code>，它是一个native方法，在<code>Class.c</code>中有个<code>Java_java_lang_Class_getPrimitiveClass</code>方法与之对应，所以JVM层面会通过<code>JVM_FindPrimitiveClass</code>函数根据”void”字符串获得jclass，最终到Java层则为<code>Class&lt;Void&gt;</code>（<font color="#dd000">其他的基本数据类型包装类中也能找到该方法</font>）</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>果然写文章是挺累人的！这篇文章的篇幅比较长，能看到这里的，不胜感激</p><p>其实九种基本数据类型对应的包装类都是大同小异，为了基本数据类型提供更多的方法接口来更好的处理数据</p><p>这篇文章就权当是Java系列文的抛砖引玉，争取慢慢的将文章写得更好</p><p>END</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Byte&lt;/strong&gt;(字节)和&lt;strong&gt;bit&lt;/strong&gt;(比特)的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;电脑是以二进制储存以及发送接收数据的，bit作为信息技术的最基本储存单位，是二进制数中的一个数位，即0或者1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Byte是字节的英文单词，它可以简称为B&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字节 Byte 和比特 bit 的换算关系是 &lt;font color=&quot;#dd0000&quot;&gt;1 Byte = 8 bit&lt;/font&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;既然说到了字节，那我们就不得不提一下&lt;strong&gt;字节和字符的区别&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;字节（Byte）&lt;/td&gt;
&lt;td&gt;字节是计算机存储容量的计量单位，表示数据量多少，1B=8bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符（Character）&lt;/td&gt;
&lt;td&gt;计算机中使用的文字和符号（如’A’、’你’、’$’等）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;而值得我们注意的是一般情况下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个英文字符就是一个字节，也就是1B&lt;ul&gt;
&lt;li&gt;一个中文字符就是两个字节，也就是2B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一名Java程序员，首篇技术文我还是决定从基础的数据类型讲起，主要是考虑到我的博客是一个循序渐进的过程。希望把技术主干搭好，然后一步步的穿插其他的技术文，丰富起来，就好比git的master和其他的branch。废话不多说，以下进入正题&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://gcoder5.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://gcoder5.com/tags/Java/"/>
    
      <category term="数据类型" scheme="https://gcoder5.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>蓄谋已久的自我介绍</title>
    <link href="https://gcoder5.com/article/8964.html"/>
    <id>https://gcoder5.com/article/8964.html</id>
    <published>2020-05-14T13:44:37.000Z</published>
    <updated>2020-05-18T13:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>hello，everyone!</p><p>我是GCoder（小声哔哔:听说博主都需要有个笔名），可以是G-Coder，也可以是GC-oder，这些都无伤大雅。我只是一个名不见经传的Java小码农，码龄估摸着得有两年了，初入博场，希望各位看官们多多关照。</p><h4 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h4><p>以大学毕业后半年为分水岭的话，前世我是一个正儿八经的机械工科生，上到机械设计，下到机械原理，我都是略有耳闻！毕业后，咱也是如同千万学子一般在诚惶诚恐和欣喜若狂之间的找到了自己的第一份工作（售前工程师），就这样干了半年，直到2017年的年前某一天，我突然细品了我的生活模式–枯燥，无味，过于安逸。我反复推敲，认真问了自己一个问题“这是我喜欢这份工作吗？”，毕竟工作是之后很长一段时间都跟自己的生活息息相关的，我真的愿意一直干这样的工作吗。我迟疑了，先后跟各位长辈们聊了自己的想法，在2017年春节后，我毅然决然的离职，选择了自己感兴趣的编程，毕竟兴趣是最好的老师啊，也是生活最佳的调味剂。而今生的故事是从半年的培训讲起，一路的磕磕碰碰，虽然无情，但也不觉得累，更多的是一种满足，那种发自内心的对感兴趣的东西，追求过程中的起起伏伏的一种刺激，一种勉励，一种全新的生活。</p><a id="more"></a><h4 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h4><p>作为一名程序员，我知道那种对技术渴求的感觉，也明白心态对生活的重要性。讲真的，我已经蓄谋已久想作为一名新时代的程序员来发发言，聊聊技术，吹吹水，跟大伙交流一下。所以，在我的博客里，我大致讲内容分成三块。</p><h5 id="技术文章（70-）"><a href="#技术文章（70-）" class="headerlink" title="技术文章（70%）"></a>技术文章（70%）</h5><p>技术文章是基础课程，发文有这么几个目的：</p><ul><li>记录学习的内容，做好笔记。因为我一直相信温故而知新，可以为师！</li><li>与看官们交流下技术，提升自己的认知。因为我知道三人行，必有我师！</li><li>从小白而来，为小白而去。我希望我的小白笔记可以帮助更多的IT萌新！</li></ul><h5 id="杂谈（20-）"><a href="#杂谈（20-）" class="headerlink" title="杂谈（20%）"></a>杂谈（20%）</h5><p>为什么要有杂谈，到底多杂，想怎么谈？生活有百态，每一态都有它独特的韵味，我们在追求技术的同时，不妨听听其他生活的声音，充实而又丰富的生活节奏，岂不快哉。</p><ul><li>杂谈范围极广，GCoder有什么心得啊，想法啊，都会写上来（其中不乏心灵鸡汤哈哈哈）</li><li>分享趣事，包括GCoder自己的一些兴趣啊（跑马，球类，极限运动，书籍等等）</li></ul><h5 id="水文（10-）"><a href="#水文（10-）" class="headerlink" title="水文（10%）"></a>水文（10%）</h5><p>人跟人之间最重要的理解，而理解的基础是沟通，水文之所以能水，就是因为能说！为什么能说，就是在自己没技术文，没杂谈的情况下，不知道发什么，却又非得想发，大抵就是这样的文章！毫无实质内容，但是却想说说话！哈哈哈</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>GCoder是一个G姓Coder的小星球。</p><p>GCoder又可以是GC和oder，垃圾回收订单。把我们的学习心得理解看成是一个个的“垃圾”，当每一个“垃圾”作为订单被各位看官们不断的消费的时候，“垃圾”会在交流中得到废品回收的效果，重新塑造一个全新的自己，这是初衷，也是博客存在的一点微薄作用。</p><p>我是GCoder，一名热爱技术的Java程序员，一名半吊子跑马选手，如果你爱技术，你爱生活，欢迎你们的关注，兴许我们是志同道合的“狐朋狗友”。岁月漫长，承蒙关照！</p><p><strong>In a lifetime ,happy to meet you.thanks.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello，everyone!&lt;/p&gt;
&lt;p&gt;我是GCoder（小声哔哔:听说博主都需要有个笔名），可以是G-Coder，也可以是GC-oder，这些都无伤大雅。我只是一个名不见经传的Java小码农，码龄估摸着得有两年了，初入博场，希望各位看官们多多关照。&lt;/p&gt;
&lt;h4 id=&quot;前世今生&quot;&gt;&lt;a href=&quot;#前世今生&quot; class=&quot;headerlink&quot; title=&quot;前世今生&quot;&gt;&lt;/a&gt;前世今生&lt;/h4&gt;&lt;p&gt;以大学毕业后半年为分水岭的话，前世我是一个正儿八经的机械工科生，上到机械设计，下到机械原理，我都是略有耳闻！毕业后，咱也是如同千万学子一般在诚惶诚恐和欣喜若狂之间的找到了自己的第一份工作（售前工程师），就这样干了半年，直到2017年的年前某一天，我突然细品了我的生活模式–枯燥，无味，过于安逸。我反复推敲，认真问了自己一个问题“这是我喜欢这份工作吗？”，毕竟工作是之后很长一段时间都跟自己的生活息息相关的，我真的愿意一直干这样的工作吗。我迟疑了，先后跟各位长辈们聊了自己的想法，在2017年春节后，我毅然决然的离职，选择了自己感兴趣的编程，毕竟兴趣是最好的老师啊，也是生活最佳的调味剂。而今生的故事是从半年的培训讲起，一路的磕磕碰碰，虽然无情，但也不觉得累，更多的是一种满足，那种发自内心的对感兴趣的东西，追求过程中的起起伏伏的一种刺激，一种勉励，一种全新的生活。&lt;/p&gt;
    
    </summary>
    
    
      <category term="首文" scheme="https://gcoder5.com/categories/%E9%A6%96%E6%96%87/"/>
    
    
      <category term="GCoder" scheme="https://gcoder5.com/tags/GCoder/"/>
    
  </entry>
  
</feed>
